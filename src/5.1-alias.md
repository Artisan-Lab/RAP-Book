# Chapter 5.1 Alias Analysis
Alias analysis is challenging, with various options that balance precision and cost, including flow sensitivity, field sensitivity, and path sensitivity. In general, there are two main approaches to analysis: the lattice-based approach and the meet-over-all-paths (MOP) approach.

## MOP-based Alias Analysis
### Features and Examples
The approach performs alias analysis for each execution path of a target function and merges the results from different paths into a final result. When encountering function calls, it recursively analyzes the callees until all dependencies are resolved. This approach is flow-sensitive and field-sensitive but context-insensitive.

TODO: ADD examples here.
 
### Quick Usage Guide

Developers can test the feature using the following command:
```
cargo rap -alias=mop
```

For example, we can apply the mop analysis to the following program:
```rust
struct MyRef<'a> { a: &'a str, }

unsafe fn f<'a>(myref: MyRef<'a>) -> MyRef<'static> {
    unsafe {
        std::mem::transmute(myref)
    }
}

fn main() {
    let string = "Hello World!".to_string();
    let args: Vec<String> = env::args().collect();
    let my_ref = unsafe { f(MyRef { a: &string })};
    if args.len() > 2 {
        drop(string);
    }
    println!("{:?}",my_ref.a);
}
```

The result is as follows:
```
15:37|RAP-FRONT|INFO|: Meaning of output: 0 for ret value; 1,2,3,... for corresponding args.
15:37|RAP-FRONT|INFO|: DefId(0:4 ~ uaf_drop2[2b18]::f)
15:37|RAP-FRONT|INFO|: [(0,1)]
15:37|RAP-FRONT|INFO|: DefId(2:9483 ~ core[efa3]::fmt::{impl#2}::new_v1)
15:37|RAP-FRONT|INFO|: [(0,2)]
```

To utilize the analysis results in other analytical features, developers can use mop as follows:
```rust
use analysis::core::alias::mop::MopAlias; // import the module
MopAlias::new(tcx).start(); // new a MopAlias object with .
```

The code above performs alias analysis for each function, recording the alias pairs between two arguments or between an argument and the return value. The results can be retrieved by decoding the following data structures.
```rust
pub type FnMap = FxHashMap<DefId, FnRetAlias>;
pub struct MopAlias<'tcx> {
    pub tcx: TyCtxt<'tcx>,
    pub fn_map: FnMap,
}

pub struct FnRetAlias {
    pub arg_size: usize,
    pub alias_vec: Vec<RetAlias>,
}

pub struct RetAlias{
    pub left_index: usize,
    pub left_field_seq: Vec<usize>, 
    pub left_may_drop: bool, 
    pub left_need_drop: bool,
    pub right_index: usize,
    pub right_field_seq: Vec<usize>,
    pub right_may_drop: bool, 
    pub right_need_drop: bool,
}
```

### Key Steps of Our MOP Algorithm
There are three key steps ([source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop.rs#L57C13-L59C50)):
```rust
let mut mop_graph = MopGraph::new(self.tcx, def_id);
mop_graph.solve_scc();
mop_graph.check(0, &mut self.fn_map);
```

* **Graph preparation**: Construct the control-flow graph for the target function. See the [source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop/graph.rs#L129).
* **SCC shrinkage**: Extract the strongly connected components (SCCs) and shrink SCCs of the control-flow graph. See the [source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop/graph.rs#L417).
* **Alias Check**: Traversal the control-flow graph and perform alias analysis. See the [source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop/mop.rs#L34)

## Lattice-based Alias Analysis

unimplemented yet.

