# Chapter 5.1. Alias Analysis
Alias analysis involves determining if two identifiers point to the same memory allocation. The task is challenging, with various options that balance precision and cost, including flow sensitivity, field sensitivity, and path sensitivity. In general, there are two main approaches to analysis: the lattice-based approach and the meet-over-all-paths (MOP) approach.

## MOP-based Alias Analysis
### Features and Examples
The approach performs alias analysis for each execution path of a target function and merges the results from different paths into a final result. When encountering function calls, it recursively analyzes the callees until all dependencies are resolved. This approach is flow-sensitive and field-sensitive but context-insensitive.

#### Case 1
In the following code, there are four possible paths depending on the enumeration value `choice`. However, only two of these paths are reachable. As a result, the return value of `foo()` is an alias of the first argument `a`; it cannot be an alias of the second argument `b`. Such an alias analysis result can be achieved using the MOP-based approach, but not the lattice-based approach.

```rust
enum Selector {
    First,
    Second,
}

fn foo<'a>(x: &'a i32, y: &'a i32, choice: Selector) -> &'a i32 {
    let a = match choice {
        Selector::First => x, 
        Selector::Second => y,
    };
    match choice {
        Selector::First => a, 
        Selector::Second => x,
    }
}
```

The corresponding MIR code is as follows:
```rust
fn foo(_1: &i32, _2: &i32, _3: Selector) -> &i32 {
    bb0: {
        StorageLive(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = _2;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = _1;
        goto -> bb4;
    }

    bb4: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb6, 1: bb5, otherwise: bb2];
    }

    bb5: {
        _0 = _1;
        goto -> bb7;
    }

    bb6: {
        _0 = _4;
        goto -> bb7;
    }

    bb7: {
        StorageDead(_4);
        return;
    }
}
```

#### Case 2: field-sensitivity 

In the following example, the return value of `foo()` is an alias of the first field of its first argument.
```rust
struct Point {
    x: i32,
    y: i32,
}

fn foo(p1: &Point) -> &i32 {
    &p1.y
}
```

The corresponding MIR code is as follows:

```rust
fn foo(_1: &Point) -> &i32 {
   bb0: {
        _0 = &((*_1).1: i32);
        return;
    }
}
```
 
### Quick Usage Guide

Developers can test the feature using the following command:
```
cargo rap -alias=mop
```

For example, we can apply the mop analysis to the first case, and the result is as follows:
```
19:20|RAP-FRONT|INFO|: Execute after_analysis() of compiler callbacks
19:20|RAP-FRONT|INFO|: Meaning of output: 0 for ret value; 1,2,3,... for corresponding args.
19:20|RAP-FRONT|INFO|: DefId(0:8 ~ alias_mop[f037]::foo)
19:20|RAP-FRONT|INFO|: [(0,1)]
19:20|RAP-FRONT|INFO|: analysis done
```

To utilize the analysis results in other analytical features, developers can use mop as follows:
```rust
use analysis::core::alias::mop::MopAlias; // import the module
MopAlias::new(tcx).start(); // new a MopAlias object with .
```

The code above performs alias analysis for each function, recording the alias pairs between two arguments or between an argument and the return value. The results can be retrieved by decoding the following data structures.
```rust
pub type FnMap = FxHashMap<DefId, FnRetAlias>;
pub struct MopAlias<'tcx> {
    pub tcx: TyCtxt<'tcx>,
    pub fn_map: FnMap,
}

pub struct FnRetAlias {
    pub arg_size: usize,
    pub alias_vec: Vec<RetAlias>,
}

pub struct RetAlias{
    pub left_index: usize,
    pub left_field_seq: Vec<usize>, 
    pub left_may_drop: bool, 
    pub left_need_drop: bool,
    pub right_index: usize,
    pub right_field_seq: Vec<usize>,
    pub right_may_drop: bool, 
    pub right_need_drop: bool,
}
```

### Key Steps of Our MOP Algorithm
There are three key steps ([source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop.rs#L57C13-L59C50)):
```rust
let mut mop_graph = MopGraph::new(self.tcx, def_id);
mop_graph.solve_scc();
mop_graph.check(0, &mut self.fn_map);
```

* **Graph preparation**: Construct the control-flow graph for the target function. See the [source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop/graph.rs#L129).
* **SCC shrinkage**: Extract the strongly connected components (SCCs) and shrink SCCs of the control-flow graph. See the [source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop/graph.rs#L417).
* **Alias Check**: Traversal the control-flow graph and perform alias analysis. See the [source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop/mop.rs#L34)

## Lattice-based Alias Analysis
TODO
